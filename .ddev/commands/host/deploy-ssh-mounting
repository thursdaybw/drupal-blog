#!/bin/bash

set -x

## #ddev-generated
## Description: Tail the main solr log
## Usage: deploy [--dry-run]
## Example: ddev deploy --dry-run 

# Function to validate GitHub token on the production server
validate_github_token_on_prod() {
  ssh -t -A root@bevansbench.com <<'EOF'
  # Extract the token from the .env file
  if [ ! -f /root/workspace/drupal-blog/.env ]; then
    echo "Error: .env file not found on production."
    exit 1
  fi

  github_pat=$(grep "COMPOSER_AUTH" /root/workspace/drupal-blog/.env | sed 's/COMPOSER_AUTH={"github-oauth":{"github.com":"\(.*\)"}}/\1/')

  if [ -z "$github_pat" ]; then
    echo "Error: No GitHub token found in the .env file."
    exit 1
  fi

  # Validate the token using GitHub API
  response=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $github_pat" https://api.github.com/user)

  if [ "$response" -eq 401 ]; then
    echo "Error: GitHub token has expired or is invalid."
    echo "Please generate a new token at https://github.com/settings/tokens and update the COMPOSER_AUTH variable in the .env file on production."
    exit 1
  elif [ "$response" -ne 200 ]; then
    echo "Error: Failed to validate GitHub token. HTTP response code: $response"
    exit 1
  else
    echo "GitHub token is valid."
  fi
EOF

  # Capture the exit code of the remote command
  if [ $? -ne 0 ]; then
    echo "GitHub token validation failed. Aborting deployment."
    exit 1
  fi
}

# Check if the dry-run flag is passed
DRY_RUN=false
if [[ "$1" == "--dry-run" ]]; then
  DRY_RUN=true
fi

# Call the validation function on production
validate_github_token_on_prod

git push origin main

# Function to generate drush cset commands from secrets.txt
# the bit about the id_rsa_sftp key doesn't belong in here.
# we need to move it, it's only here because here was the
# only place reading the secrets.txt previously.
generate_drush_commands() {
  while IFS= read -r line; do
    entity=$(echo "$line" | cut -d ' ' -f 1)
    key=$(echo "$line" | cut -d ' ' -f 2)

    if [[ "$entity" == "sftp_key" ]]; then
      value=$(echo "$line" | cut -d ' ' -f 2)
      # Decode and write the SSH key into the container
      echo "mkdir -p /home/http/.ssh"
      echo "echo \"$value\" | base64 -d > /home/http/.ssh/id_rsa_sftp"
      echo "chmod 600 /home/http/.ssh/id_rsa_sftp"
      echo "chown www-data:www-data /home/http/.ssh/id_rsa_sftp"
    else
      value=$(echo "$line" | cut -d ' ' -f 3)
      echo "./vendor/bin/drush cset $entity $key $value -y"
    fi

  done < .ddev/secrets.txt
}

# Store the generated commands in a variable
DRUSH_COMMANDS=$(generate_drush_commands)

# Heredoc content stored in a variable, including dynamic commands
SSH_COMMANDS=$(cat <<EOF
cd /root/workspace/drupal-blog

# Change ownership to root
sudo chown -R root:root .

# Pull the latest changes from the main branch
git pull origin main

# Change ownership to www-data
sudo chown -R www-data:www-data .

# Rebuild and restart the Docker containers
docker-compose down && docker-compose build && docker-compose up -d

# Ensure SSH key and known_hosts inside the container
docker-compose exec -T -u www-data appserver bash -x -c '
mkdir -p /home/http/.ssh/ &&
cat > /home/http/.ssh/known_hosts << "EOF_KNOWN_HOSTS"
github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=
EOF_KNOWN_HOSTS
chmod 644 /home/http/.ssh/known_hosts &&
chown www-data:www-data /home/http/.ssh/known_hosts
'
# Now execute the rest of the commands, allowing \$DRUSH_COMMANDS to expand properly
docker-compose exec -T -u www-data appserver bash -x -c "
cd /var/www &&
composer install &&
./vendor/bin/drush updb -y &&
./vendor/bin/drush cim -y &&
$DRUSH_COMMANDS &&
./vendor/bin/drush simple-oauth:generate-keys ../keys &&
./vendor/bin/drush cr
"

# Mount SSHFS inside the container
docker exec -it -u www-data drupal-blog_appserver_1 bash -c '
mkdir -p /var/www/html/sites/default/files/receipts &&
chown www-data:www-data /var/www/html/sites/default/files/receipts &&
sshfs -o IdentityFile=/home/http/.ssh/id_rsa_sftp,StrictHostKeyChecking=no,UserKnownHostsFile=/dev/null,allow_other,uid=33,gid=33,reconnect,sshfs_sync \
20187@hk-s020.rsync.net:/data1/home/20187/receipts /var/www/html/sites/default/files/receipts'

EOF
)

if [ "$DRY_RUN" = true ]; then
  echo "$SSH_COMMANDS"
else
  # Connect to the remote host with forced pseudo-terminal allocation
  ssh -t -A root@bevansbench.com "$SSH_COMMANDS"
fi

