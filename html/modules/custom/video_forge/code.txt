
=== ./src/Form/CaptionsForm.php ===

<?php

declare(strict_types=1);

namespace Drupal\video_forge\Form;

use Drupal\Core\Form\FormBase;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Extension\ModuleHandlerInterface;
use Drupal\Core\File\FileUrlGeneratorInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;


/**
 * Provides a Fancy captions form.
 */
final class CaptionsForm extends FormBase {

  /**
   * The file URL generator service.
   *
   * @var \Drupal\Core\File\FileUrlGeneratorInterface
   */
  protected $fileUrlGenerator;

  /**
   * Constructs a new CaptionsForm.
   *
   * @param \Drupal\Core\File\FileUrlGeneratorInterface $file_url_generator
   *   The file URL generator service.
   */
  public function __construct(FileUrlGeneratorInterface $file_url_generator) {
    $this->fileUrlGenerator = $file_url_generator;
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container) {
    return new static(
      $container->get('file_url_generator')
    );
  }

  /**
   * {@inheritdoc}
   */
  public function getFormId(): string {
    return 'video_forge_captions';
  }

  public function buildForm(array $form, FormStateInterface $form_state) {
	  $form['video'] = [
		  '#type' => 'managed_file',
		  '#title' => $this->t('Upload Video'),
		  '#description' => $this->t('Upload the video file to generate captions. Supported formats: MP4, MOV, AVI.'),
		  '#upload_location' => 'public://videos/',
		  '#upload_validators' => [
			  'file_validate_extensions' => ['mp4 mov avi'],
		  ],
		  '#required' => TRUE,
	  ];
	  $form['submit'] = [
		  '#type' => 'submit',
		  '#value' => $this->t('Generate Captions'),
	  ];

	  return $form;
  }

  /**
   * {@inheritdoc}
   */
  public function validateForm(array &$form, FormStateInterface $form_state): void {
	  // @todo Validate the form here.
	  // Example:
	  // @code
	  //   if (mb_strlen($form_state->getValue('message')) < 10) {
	  //     $form_state->setErrorByName(
	  //       'message',
	  //       $this->t('Message should be at least 10 characters.'),
	  //     );
	  //   }
	  // @endcode
  }

  /**
   * {@inheritdoc}
   */
  public function submitForm(array &$form, FormStateInterface $form_state): void {
	  $fid = $form_state->getValue('video')[0]; // File ID from managed file
	  $file = \Drupal::entityTypeManager()->getStorage('file')->load($fid);

	  if ($file) {
		  // Mark the file as permanent (so itâ€™s not deleted by cron)
		  $file->setPermanent();
		  $file->save();

		  // Get the file URI and prepare it for processing
		  $file_uri = $file->getFileUri();
		  $file_path = \Drupal::service('file_system')->realpath($file_uri);

		  \Drupal::messenger()->addMessage($this->t('File uploaded: @path', ['@path' => $file_path]));

		  // Pass the file path to the Whisper and FFmpeg processing logic
		  $this->processVideo($file_path);
	  }
  }

  /**
   * Process the video file with Whisper and FFmpeg.
   */
  private function processVideo(string $file_path): void {
	  $output_dir = dirname($file_path); // Use the same directory for output
	  $command = "/home/bevan/.local/bin/whisper --model medium -f json \"$file_path\" --output_dir \"$output_dir\" --word_timestamps True";

	  // Capture output and return code
	  $output = [];
	  $return_var = 0;
	  exec($command, $output, $return_var);

	  // Log the command and its output
	  \Drupal::logger('video_forge')->info('Command: @command', ['@command' => $command]);
	  \Drupal::logger('video_forge')->info('Output: @output', ['@output' => implode("\n", $output)]);
	  \Drupal::logger('video_forge')->info('Return code: @code', ['@code' => $return_var]);

	  if ($return_var !== 0) {
		  \Drupal::messenger()->addError($this->t('Whisper failed to process the video.'));
		  return;
	  }

	  // Locate the JSON file generated by Whisper
	  $json_file = str_replace('.mp4', '.json', $file_path);

	  if (!file_exists($json_file)) {
		  \Drupal::messenger()->addError($this->t('Whisper JSON file not found.'));
		  return;
	  }
	  else {
		  $this->saveManagedFile($json_file, 'Generated JSON File');
	  }

	  // Run your PHP script to generate ASS captions
	  $ass_file = str_replace('.mp4', '.ass', $file_path);
	  // Get the module's path dynamically
	  $module_path = \Drupal::service('module_handler')->getModule('video_forge')->getPath();
	  $php_script = DRUPAL_ROOT . '/' . $module_path . '/captions.php';


	  $command = "php \"$php_script\" \"$json_file\" \"$ass_file\"";
	  exec($command, $output, $return_var);

	  if ($return_var !== 0) {
		  \Drupal::messenger()->addError($this->t('Failed to generate ASS captions.'));
		  return;
	  }
	  else {
		  $this->saveManagedFile($ass_file, 'Generated ASS File');
	  }

	  // Use FFmpeg to render captions into the video
	  $output_video = str_replace('.mp4', '_with_captions.mp4', $file_path);
	  $ass_file = str_replace('.mp4', '.ass', $file_path);

	  $command = "ffmpeg -i \"$file_path\" -vf subtitles=\"$ass_file\" -c:a copy \"$output_video\"";
	  exec($command, $output, $return_var);

	  // Log the command and its output
	  \Drupal::logger('video_forge')->info('Command: @command', ['@command' => $command]);
	  \Drupal::logger('video_forge')->info('Output: @output', ['@output' => implode("\n", $output)]);
	  \Drupal::logger('video_forge')->info('Return code: @code', ['@code' => $return_var]);

	  if ($return_var !== 0) {
		  \Drupal::messenger()->addError($this->t('Failed to render captions into the video.'));
		  return;
	  }
	  else {
		  $this->saveManagedFile($output_video, 'Video with Captions');
	  }

	  // Generate a public URL for the processed video
	  // Load the managed File entities by their URIs.
	  $json_file_entity = \Drupal::entityTypeManager()->getStorage('file')->loadByProperties(['uri' => 'public://videos/' . basename($json_file)]);
	  $ass_file_entity = \Drupal::entityTypeManager()->getStorage('file')->loadByProperties(['uri' => 'public://videos/' . basename($ass_file)]);
	  $output_video_entity = \Drupal::entityTypeManager()->getStorage('file')->loadByProperties(['uri' => 'public://videos/' . basename($output_video)]);

	  // Extract the first result since loadByProperties returns an array.
	  $json_file_entity = reset($json_file_entity);
	  $ass_file_entity = reset($ass_file_entity);
	  $output_video_entity = reset($output_video_entity);

	  // Generate URLs from the managed File entities.
	  $json_file_url = $json_file_entity ? $this->fileUrlGenerator->generateAbsoluteString($json_file_entity->getFileUri()) : NULL;
	  $ass_file_url = $ass_file_entity ? $this->fileUrlGenerator->generateAbsoluteString($ass_file_entity->getFileUri()) : NULL;
	  $output_video_url = $output_video_entity ? $this->fileUrlGenerator->generateAbsoluteString($output_video_entity->getFileUri()) : NULL;
	  $this->t('Download your video with captions: <a href=":url" target="_blank">:url</a>', [
		  ':url' => $output_video_url,
	  ]);

	  \Drupal::messenger()->addMessage(
		  $this->t('Artifacts generated: <ul><li><a href=":json_url" target="_blank">JSON</a></li><li><a href=":ass_url" target="_blank">ASS</a></li><li><a href=":mp4_url" target="_blank">Video with Captions</a></li></ul>', [
			  ':json_url' => $json_file_url,
			  ':ass_url' => $ass_file_url,
			  ':mp4_url' => $output_video_url,
		  ]));

	  \Drupal::messenger()->addMessage($this->t('Whisper successfully processed the video.'));
  }

  /**
   * Save a file as a managed file in Drupal.
   *
   * @param string $file_path
   *   The real path to the file.
   * @param string $description
   *   A description for the managed file.
   */
  private function saveManagedFile(string $file_path, string $description): void {
	  $file_uri = 'public://videos/' . basename($file_path);

	  // Copy the file to the managed file location (if not already there).
	  if (!file_exists($file_uri)) {
		  \Drupal::service('file_system')->copy($file_path, $file_uri, \Drupal\Core\File\FileSystemInterface::EXISTS_REPLACE);
	  }

	  // Create the File entity.
	  $file = \Drupal\file\Entity\File::create([
		  'uri' => $file_uri,
		  'status' => 1, // Permanent file.
		  'uid' => \Drupal::currentUser()->id(),
	  ]);

	  $file->save();
  }

}

=== ./src/Controller/GenerateCaptionsController.php ===

<?php

declare(strict_types=1);

namespace Drupal\video_forge\Controller;

use Drupal\Core\Controller\ControllerBase;

/**
 * Returns responses for Video Forge routes.
 */
final class GenerateCaptionsController extends ControllerBase {

	public function generate(MediaInterface $media) {
		\Drupal::logger('video_forge')->info('Generating captions for Media ID: @id, Bundle: @bundle', [
			'@id' => $media->id(),
			'@bundle' => $media->bundle(),
		]);
	}


  /**
   * Builds the response.
   */
  public function __invoke(): array {

    $build['content'] = [
      '#type' => 'item',
      '#markup' => $this->t('It works!'),
    ];

    return $build;
  }

}

=== ./src/Access/MediaTypeAccessCheck.php ===

<?php
namespace Drupal\video_forge\Access;

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Logger\LoggerChannelFactoryInterface;

/**
 * Provides access control for media type-specific routes.
 */
class MediaTypeAccessCheck {
  /**
   * The logger service.
   *
   * @var \Drupal\Core\Logger\LoggerChannelFactoryInterface
   */
  protected $logger;

  /**
   * Constructs the MediaTypeAccessCheck.
   */
  public function __construct(LoggerChannelFactoryInterface $logger_factory) {
    $this->logger = $logger_factory->get('fancy_captions');
  }

  /**
   * Checks access for the media type.
   *
   * @param \Drupal\Core\Routing\RouteMatchInterface $route_match
   *   The current route match.
   *
   * @return \Drupal\Core\Access\AccessResult
   *   The access result.
   */
  public function access(RouteMatchInterface $route_match) {
	  $media = $route_match->getParameter('media');

	  if (!$media) {
		  $this->logger->error('Media parameter is missing or null.');
		  return AccessResult::forbidden();
	  }

	  if ($media instanceof \Drupal\media\Entity\Media) {
		  $this->logger->info('Media ID: @id, Bundle: @bundle', [
			  '@id' => $media->id(),
			  '@bundle' => $media->bundle(),
		  ]);
	  } else {
		  $this->logger->error('Media is not an instance of Media entity.');
	  }

	  return AccessResult::forbidden();
  }

}

=== ./captions.php ===

<?php
if ($argc !== 3) {
    echo "Usage: php captions.php input.json output.ass\n";
    exit(1);
}

$jsonFile = $argv[1];
$outputFile = $argv[2];

// Read and parse the JSON file
$jsonContent = file_get_contents($jsonFile);
$data = json_decode($jsonContent, true);

if (!$data) {
    echo "Error: Failed to parse JSON file.\n";
    exit(1);
}

// Font sizes
$fontsize_l = "90"; // Highlighted word font size
$fontsize_s = "80"; // Default font size

// Define presets with animations and additional settings
$presets = [
    "Hormozi" => [
        "style" => "Style: Hormozi,Anton SC,$fontsize_s,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,-1,0,0,0,110,90,-20,0,1,4,1,8,200,200,700,1",
        "highlight" => [
            "color" => "&H29F602", // Bright green
            "size" => $fontsize_l,
            "bold" => true
        ],
        "animation" => "fade-in"
    ],
    "MrBeast" => [
        "style" => "Style: MrBeast,Impact,$fontsize_s,&H00FFFF00,&H00FFFF00,&H00000000,&H00000000,-1,0,0,0,100,100,-20,0,1,3,1,2,200,200,700,1",
        "highlight" => [
            "color" => "&H0000FF", // Blue
            "size" => $fontsize_l,
            "bold" => true
        ],
        "animation" => "none"
    ],
    "GaryVee" => [
        "style" => "Style: GaryVee,Montserrat,$fontsize_s,&H00FF4500,&H00FF4500,&H00000000,&H00000000,-1,0,0,0,100,90,-10,0,1,2,1,2,200,200,700,1",
        "highlight" => [
            "color" => "&HFF0000", // Red
            "size" => $fontsize_l,
            "bold" => true
        ],
        "animation" => "slide-up"
    ],
    "FadeIn" => [
        "style" => "Style: FadeIn,Anton SC,$fontsize_s,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,-1,0,0,0,100,70,-20,0,1,5,0,8,200,200,700,1",
        "highlight" => [
            "color" => "&HFFFF00", // Yellow
            "size" => $fontsize_l,
            "bold" => true
        ],
        "animation" => "fade-in"
    ],
    "ShadowYellow" => [
        "style" => "Style: ShadowYellow,Anton SC,$fontsize_s,&H00FFFF00,&H00FFFF00,&H00000000,&H00000000,-1,0,0,0,100,70,-30,0,1,2,3,2,200,200,700,1",
        "highlight" => [
            "color" => "&HFFFF00", // Yellow
            "size" => $fontsize_l,
            "bold" => false
        ],
        "animation" => "none"
    ]
];

// Choose a preset
$chosenPresetKey = "Hormozi"; // Change this to select a different preset
$chosenPreset = $presets[$chosenPresetKey];

// Generate ASS header
$assHeader = "[Script Info]
Title: Phrase-timed Subtitles
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
" . $chosenPreset['style'] . "\n";

// Define maximum words and duration for a sub-phrase
$maxWords = 6;
$maxDuration = 2.0; // Max duration for each phrase (seconds)
$pauseThreshold = 0.3; // Minimum pause to trigger a split (seconds)

$assEvents = [];

foreach ($data["segments"] as $segment) {
    $words = $segment["words"];
    $subPhraseStart = $words[0]["start"];
    $subPhraseWords = [];
    $wordCount = 0;

    foreach ($words as $i => $wordInfo) {
        $word = $wordInfo["word"];
        $start = $wordInfo["start"];
        $end = $wordInfo["end"];

        // Add the current word to the sub-phrase array
        $subPhraseWords[] = $wordInfo;
        $wordCount++;

        // Check for the next word to determine split conditions
        $nextWordStart = isset($words[$i + 1]) ? $words[$i + 1]["start"] : null;
        $subPhraseDuration = $end - $subPhraseStart;
        $pauseDuration = $nextWordStart ? $nextWordStart - $end : null;

        // If split conditions are met, create an ASS event for the sub-phrase
        if ($wordCount >= $maxWords || $subPhraseDuration >= $maxDuration || ($pauseDuration && $pauseDuration >= $pauseThreshold) || !$nextWordStart) {
            // Generate the text for this sub-phrase, with the currently spoken word highlighted
            foreach ($subPhraseWords as $j => $subWordInfo) {
		    $highlightedPhrase = "";
		    if ($j === 0) {
		      $highlightedPhrase = "{\\fad(500,0)}";
		    } 

		    foreach ($subPhraseWords as $k => $otherWordInfo) {
			    $otherWord = $otherWordInfo["word"];
			    if ($j === $k) {
				    // Apply highlight style to the current word
				    $highlightedPhrase .= "{\\c{$chosenPreset['highlight']['color']}\\fs{$chosenPreset['highlight']['size']}\\b" .
					    ($chosenPreset['highlight']['bold'] ? "1" : "0") .
					    "}{$otherWord}{\\c&HFFFFFF&\\fs$fontsize_s\\b0}";
			    } else {
				    // Default style for non-highlighted words
				    $highlightedPhrase .= "{$otherWord}";
			    }
		    }

                // Apply animation effect
                $animationEffect = "";
                if ($chosenPreset['animation'] === "fade-in") {
                    $animationEffect = "\\fad(500,0)"; // 500ms fade-in, no fade-out
                }

                // Format start and end times for ASS
                $subStartTime = gmdate("H:i:s", floor($subWordInfo["start"])) . '.' . sprintf('%02d', ($subWordInfo["start"] - floor($subWordInfo["start"])) * 100);
                $subEndTime = gmdate("H:i:s", floor($subWordInfo["end"])) . '.' . sprintf('%02d', ($subWordInfo["end"] - floor($subWordInfo["end"])) * 100);

                // Create ASS dialogue line
		// Create ASS dialogue line
		$assEvent = "Dialogue: 0,{$subStartTime},{$subEndTime},{$chosenPresetKey},,0,0,0,,{$highlightedPhrase}";
		$assEvents[] = $assEvent;
	    }

            // Reset for the next sub-phrase
            $subPhraseStart = $nextWordStart; // Reset start time for the next phrase
            $subPhraseWords = []; // Clear sub-phrase words
            $wordCount = 0;
        }
    }
}

// Combine header and events
$assContent = $assHeader . "\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n" . implode("\n", $assEvents);

// Save the ASS file with UTF-8 BOM encoding
file_put_contents($outputFile, "\xEF\xBB\xBF" . $assContent);

echo "Phrase-timed ASS file with {$chosenPresetKey} preset and animations has been created: {$outputFile}\n";


=== ./video_forge.info.yml ===

name: 'Video Forge'
type: module
description: 'Provides a feature to upload a video, transcribe it and add fancy captions'
package: Forge Suite
core_version_requirement: ^10 || ^11

=== ./video_forge.routing.yml ===

video_forge.video_upload:
  path: '/video-forge/video/upload'
  defaults:
    _title: 'Captions Video Upload'
    _form: 'Drupal\video_forge\Form\CaptionsForm'
  requirements:
    _permission: 'access content'
media.forge.generate_captions:
  path: '/media/{media}/generate-captions'
  defaults:
    _controller: '\Drupal\video_forge\Controller\GenerateCaptionsController::generate'
    _title: 'Generate Captions'
  requirements:
    _permission: 'administer media'
    _custom_access: 'video_forge.media_type_access_check:access'
  options:
    parameters:
      media:
        type: entity:media

=== ./video_forge.links.task.yml ===

media.generate_captions:
  route_name: media.forge.generate_captions 
  title: 'Generate Captions'
  base_route: entity.media.canonical
  weight: 1
  requirements:
    _custom_access: 'Drupal\video_forge\Access\MediaTypeAccessCheck::access'
  options:
    parameters:
      media:
        type: entity:media
    # Add a condition for the specific media type
    context:
      media:
        bundles:
          - forge_video

=== ./video_forge.services.yml ===

services:
  video_forge.media_type_access_check:
    class: Drupal\video_forge\Access\MediaTypeAccessCheck
    arguments: ['@logger.factory']


=== ./code.txt ===

